import{_ as e,c as o,f as r,o as n}from"./app-GLVeLgbA.js";const a={};function p(s,t){return n(),o("div",null,[...t[0]||(t[0]=[r('<h3 id="udp的特点" tabindex="-1"><a class="header-anchor" href="#udp的特点"><span>UDP的特点</span></a></h3><p>UDP的三个特点：面向无连接、不可靠、基于数据报。</p><h3 id="基于数据包" tabindex="-1"><a class="header-anchor" href="#基于数据包"><span>基于数据包</span></a></h3><p>基于<strong>数据报</strong>是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是IP层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。正因为<strong>基于数据报</strong>和<strong>基于字节流</strong>的差异，<strong>TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。</strong></p>',4)])])}const P=e(a,[["render",p]]),i=JSON.parse('{"path":"/note/computer/network/UDP.html","title":"关于UDP","lang":"zh-CN","frontmatter":{"title":"关于UDP","category":["computer"],"date":"2025-12-20T00:00:00.000Z","pageInfo":["author","Word","readingTime","date","Category","Tag"],"description":"UDP的特点 UDP的三个特点：面向无连接、不可靠、基于数据报。 基于数据包 基于数据报是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是IP层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 T...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"关于UDP\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-20T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"马里凡\\",\\"url\\":\\"https://mister-hope.com\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/note/computer/network/UDP.html"}],["meta",{"property":"og:site_name","content":"马里凡"}],["meta",{"property":"og:title","content":"关于UDP"}],["meta",{"property":"og:description","content":"UDP的特点 UDP的三个特点：面向无连接、不可靠、基于数据报。 基于数据包 基于数据报是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是IP层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 T..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:published_time","content":"2025-12-20T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":0.96,"words":289},"filePathRelative":"note/computer/network/UDP.md","excerpt":"<h3>UDP的特点</h3>\\n<p>UDP的三个特点：面向无连接、不可靠、基于数据报。</p>\\n<h3>基于数据包</h3>\\n<p>基于<strong>数据报</strong>是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是IP层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。正因为<strong>基于数据报</strong>和<strong>基于字节流</strong>的差异，<strong>TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。</strong></p>","autoDesc":true}');export{P as comp,i as data};
