import{_ as s,c as e,f as t,o as a}from"./app-GLVeLgbA.js";const i="/assets/serialization-Cr00Vrqh.png",r="/assets/header-body-DxZDH7N7.png",l={};function o(p,n){return a(),e("div",null,[...n[0]||(n[0]=[t('<blockquote><p>本文参考JavaGuide:<a href="https://javaguide.cn/distributed-system/rpc/http_rpc.html" target="_blank" rel="noopener noreferrer">有了 HTTP 协议，为什么还要有 RPC ？ </a></p></blockquote><div class="hint-container tip"><p class="hint-container-title">总结</p><ol><li><p><strong>问题</strong>：TCP 是流式协议，没有消息边界</p></li><li><p><strong>现象</strong>：会出现&quot;粘包&quot;（多个消息粘在一起）和&quot;拆包&quot;（一个消息被拆开）</p></li><li><p><strong>解决方案</strong>：消息头 + 消息体</p><ul><li><strong>消息头</strong>：固定格式，包含消息体长度等信息</li><li><strong>消息体</strong>：实际要传输的数据</li></ul></li><li><p><strong>工作流程</strong>：</p><ul><li><p>发送方：计算长度 → 添加头部 → 发送</p></li><li><p>接收方：读取头部 → 解析长度 → 读取对应长度的数据</p><p>更细节知识参考：<a href="https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&amp;mid=2247492768&amp;idx=1&amp;sn=686087613bf6689e899b2cdb606ea780&amp;source=41&amp;poc_token=HLYKRmmjMLPXQX--iK9pbkhcHI9MXYqwCBoGPg9k" target="_blank" rel="noopener noreferrer">为什么要组装发送的数据</a></p><p>基于上方文章补充：当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时。</p></li></ul></li><li><p><strong>优点</strong>：</p><ul><li>明确的消息边界</li><li>可以传输任意长度的数据</li><li>支持复杂协议扩展</li></ul></li></ol><ul><li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层<mark>需要定义消息格式用于界定 <strong>消息边界</strong></mark>。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。这就是为什么几乎所有基于 TCP 的协议（HTTP、WebSocket、Redis 协议等）都需要定义自己的消息格式来界定消息边界的原因。</li><li><strong>TCP 是传输层的协议</strong> ，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的 <strong>应用层协议</strong> 而已。</li></ul></div><h3 id="tcp的特点" tabindex="-1"><a class="header-anchor" href="#tcp的特点"><span>TCP的特点</span></a></h3><p>TCP的三个特点：面向连接、可靠、基于字节流。</p><h3 id="基于字节流" tabindex="-1"><a class="header-anchor" href="#基于字节流"><span>基于字节流</span></a></h3><p>字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 01 串 。纯裸 TCP 收发的这些 01 串之间是 没有任何边界 的，你根本不知道到哪个地方才算一条完整消息。</p><p>这便出现了所谓的<code>粘包问题</code>。</p><p>由于纯裸 TCP 是不能直接拿来用的，所以在这个基础上加入一些 自定义的规则 ，用于区分消息边界 。即消息头和消息体。</p><h3 id="消息头和消息体" tabindex="-1"><a class="header-anchor" href="#消息头和消息体"><span>消息头和消息体</span></a></h3><p>于是我们会把每条要发送的数据都包装一下，比如加入消息头 ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的消息体 。</p><p>而这里头提到的 <strong>消息头</strong> ，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的 <strong>协议。</strong></p><p>每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能 <strong>有区别，但原理都类似</strong>。</p><p><strong>于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p><h3 id="tcp传输的内容" tabindex="-1"><a class="header-anchor" href="#tcp传输的内容"><span>TCP传输的内容</span></a></h3><p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p><p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度（Content-Length）</strong>。</p><p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p><p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p><img src="'+i+'" alt="序列化" style="zoom:80%;"><p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p><p>截图如下。</p><img src="'+r+`" alt="Header和Body" style="zoom:80%;"><h3 id="小疑问" tabindex="-1"><a class="header-anchor" href="#小疑问"><span>小疑问：</span></a></h3><h4 id="_1、为什么post请求有content-length-而get请求没有" tabindex="-1"><a class="header-anchor" href="#_1、为什么post请求有content-length-而get请求没有"><span>1、为什么Post请求有Content-Length,而Get请求没有？</span></a></h4><ul><li><strong>GET 请求</strong>通常用于<strong>获取数据</strong></li><li>参数通过 <strong>URL 查询字符串</strong>传递（<code>?id=123</code>）</li><li><strong>没有请求体</strong>（Request Body）</li><li>既然没有请求体，自然不需要 <code>Content-Length</code></li></ul><h4 id="_2、什么时候需要content-length" tabindex="-1"><a class="header-anchor" href="#_2、什么时候需要content-length"><span>2、什么时候需要<strong>Content-Length</strong>？</span></a></h4><p><strong>场景1：有请求体的请求</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>POST /api/users HTTP/1.1</span></span>
<span class="line"><span>Content-Type: application/json</span></span>
<span class="line"><span>Content-Length: 56  # ← 必须的</span></span>
<span class="line"><span></span></span>
<span class="line"><span>{&quot;username&quot;: &quot;test&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;email&quot;: &quot;test@example.com&quot;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>场景2：分块传输（Transfer-Encoding: chunked）</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>POST /api/upload HTTP/1.1</span></span>
<span class="line"><span>Transfer-Encoding: chunked  # ← 分块传输</span></span>
<span class="line"><span>Content-Type: multipart/form-data</span></span>
<span class="line"><span></span></span>
<span class="line"><span>7\\r\\n</span></span>
<span class="line"><span>Mozilla\\r\\n</span></span>
<span class="line"><span>9\\r\\n</span></span>
<span class="line"><span>Developer\\r\\n</span></span>
<span class="line"><span>7\\r\\n</span></span>
<span class="line"><span>Network\\r\\n</span></span>
<span class="line"><span>0\\r\\n</span></span>
<span class="line"><span>\\r\\n</span></span>
<span class="line"><span># 分块传输时，不需要 Content-Length</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>场景3：空的请求体也需要</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>POST /api/ping HTTP/1.1</span></span>
<span class="line"><span>Content-Length: 0  # ← 明确表示请求体长度为0</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 空行下面是请求体（没有内容）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,32)])])}const c=s(l,[["render",o]]),g=JSON.parse('{"path":"/note/computer/network/TCP.html","title":"关于TCP","lang":"zh-CN","frontmatter":{"title":"关于TCP","category":["computer"],"date":"2025-12-20T00:00:00.000Z","pageInfo":["author","Word","readingTime","date","Category","Tag"],"description":"本文参考JavaGuide:有了 HTTP 协议，为什么还要有 RPC ？ 总结 问题：TCP 是流式协议，没有消息边界 现象：会出现\\"粘包\\"（多个消息粘在一起）和\\"拆包\\"（一个消息被拆开） 解决方案：消息头 + 消息体 消息头：固定格式，包含消息体长度等信息 消息体：实际要传输的数据 工作流程： 发送方：计算长度 → 添加头部 → 发送 接收方：读取...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"关于TCP\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-20T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"马里凡\\",\\"url\\":\\"https://mister-hope.com\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/note/computer/network/TCP.html"}],["meta",{"property":"og:site_name","content":"马里凡"}],["meta",{"property":"og:title","content":"关于TCP"}],["meta",{"property":"og:description","content":"本文参考JavaGuide:有了 HTTP 协议，为什么还要有 RPC ？ 总结 问题：TCP 是流式协议，没有消息边界 现象：会出现\\"粘包\\"（多个消息粘在一起）和\\"拆包\\"（一个消息被拆开） 解决方案：消息头 + 消息体 消息头：固定格式，包含消息体长度等信息 消息体：实际要传输的数据 工作流程： 发送方：计算长度 → 添加头部 → 发送 接收方：读取..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:published_time","content":"2025-12-20T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":4.4,"words":1320},"filePathRelative":"note/computer/network/TCP.md","excerpt":"<blockquote>\\n<p>本文参考JavaGuide:<a href=\\"https://javaguide.cn/distributed-system/rpc/http_rpc.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">有了 HTTP 协议，为什么还要有 RPC ？ </a></p>\\n</blockquote>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">总结</p>\\n<ol>\\n<li>\\n<p><strong>问题</strong>：TCP 是流式协议，没有消息边界</p>\\n</li>\\n<li>\\n<p><strong>现象</strong>：会出现\\"粘包\\"（多个消息粘在一起）和\\"拆包\\"（一个消息被拆开）</p>\\n</li>\\n<li>\\n<p><strong>解决方案</strong>：消息头 + 消息体</p>\\n<ul>\\n<li><strong>消息头</strong>：固定格式，包含消息体长度等信息</li>\\n<li><strong>消息体</strong>：实际要传输的数据</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>工作流程</strong>：</p>\\n<ul>\\n<li>\\n<p>发送方：计算长度 → 添加头部 → 发送</p>\\n</li>\\n<li>\\n<p>接收方：读取头部 → 解析长度 → 读取对应长度的数据</p>\\n<p>更细节知识参考：<a href=\\"https://mp.weixin.qq.com/s?__biz=MzkxNTU5MjE0MQ==&amp;mid=2247492768&amp;idx=1&amp;sn=686087613bf6689e899b2cdb606ea780&amp;source=41&amp;poc_token=HLYKRmmjMLPXQX--iK9pbkhcHI9MXYqwCBoGPg9k\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">为什么要组装发送的数据</a></p>\\n<p>基于上方文章补充：当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时。</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>优点</strong>：</p>\\n<ul>\\n<li>明确的消息边界</li>\\n<li>可以传输任意长度的数据</li>\\n<li>支持复杂协议扩展</li>\\n</ul>\\n</li>\\n</ol>\\n<ul>\\n<li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层<mark>需要定义消息格式用于界定 <strong>消息边界</strong></mark>。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。这就是为什么几乎所有基于 TCP 的协议（HTTP、WebSocket、Redis 协议等）都需要定义自己的消息格式来界定消息边界的原因。</li>\\n<li><strong>TCP 是传输层的协议</strong> ，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的 <strong>应用层协议</strong> 而已。</li>\\n</ul>\\n</div>","autoDesc":true}');export{c as comp,g as data};
